https://leetcode.cn/problems/maximum-ascending-subarray-sum/description/ 

- Solution 1 by enumerating
```
public class Solution {
    public int MaxAscendingSum(int[] nums) {
        var maxSum = nums[0];
        var tempSum = nums[0];
        for (var i = 1; i < nums.Length; i++)
        {
            if (nums[i] > nums[i - 1])
            {
                tempSum += nums[i];
            }
            else
            {
                maxSum = Math.Max(maxSum, tempSum);
                tempSum = nums[i];
            }
        }

        maxSum = Math.Max(maxSum, tempSum);
        return maxSum;
    }
}
```
**Python**
```
class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        max_sum = temp_sum = nums[0]
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                temp_sum += nums[i]
            else:
                max_sum = max(max_sum, temp_sum)
                temp_sum = nums[i]

        max_sum = max(max_sum, temp_sum)
        return max_sum
        
```

---

- Recommendation 1 by dynamic arrange
```
class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        ans = 0
        i, n = 0, len(nums)
        while i < n:
            s = nums[i]
            i += 1
            while i < n and nums[i] > nums[i - 1]:
                s += nums[i]
                i += 1
            ans = max(ans, s)
        return ans
        
```
