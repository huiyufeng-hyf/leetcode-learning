https://leetcode.cn/problems/maximum-population-year/description/ 

- Solution by enumeration and greedy
```
public class Solution {
    public int MaximumPopulation(int[][] logs) {
        var minYear = logs[0][0];
        var maxCount = 0;
        for (var i = 0; i < logs.Length; i++)
        {
            var tempYear = logs[i][0];
            var tempCount = 1;
            for (var j = 0; j < logs.Length; j++)
            {
                if (j == i)
                    continue;
                if (logs[j][0] <= tempYear)
                {
                    if (logs[j][1] - 1 >= tempYear)
                        tempCount++;
                }
            }
            if (tempCount > maxCount)
            {
                maxCount = tempCount;
                minYear = tempYear;
            }
            else if (tempCount == maxCount && tempYear < minYear)
            {
                minYear = tempYear;
            }
        }
        return minYear;
    }
}
```
**Python**
```
class Solution:
    def maximumPopulation(self, logs: List[List[int]]) -> int:
        min_year = logs[0][0]
        max_count = 0
        for i in range(0, len(logs)):
            temp_year = logs[i][0]
            temp_count = 1
            for j in range(0, len(logs)):
                if j == i:
                    continue
                if logs[j][0] <= temp_year and (logs[j][1] - 1) >= temp_year:
                    temp_count += 1
            if temp_count > max_count:
                max_count = temp_count
                min_year = temp_year
            elif temp_count == max_count and temp_year < min_year:
                min_year = temp_year
        return min_year
```

---

- Recommendation by maintaining array
```
class Solution:
    def maximumPopulation(self, logs: List[List[int]]) -> int:
        delta = [0] * 101
        offset = 1950
        for b, d in logs:
            delta[b - offset] += 1
            delta[d - offset] -= 1
        mx = 0
        res = 0
        curr = 0
        for i in range(101):
            curr += delta[i]
            if curr > mx:
                mx = curr
                res = i
        return res + offset
```
