https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/description/

- Solution by copilot
```
public class Solution {
    public bool FindRotation(int[][] mat, int[][] target) {
        var n = mat.Length;
        var rot0 = true;
        var rot90 = true;
        var rot180 = true;
        var rot270 = true;

        for (var i = 0; i < n; i++)
        {
            for (var j = 0; j < n; j++)
            {
                var v = mat[i][j];
                if (v != target[i][j]) rot0 = false;
                if (v != target[j][n - 1 - i]) rot90 = false;
                if (v != target[n - 1 - i][n - 1 - j]) rot180 = false;
                if (v != target[n - 1 - j][i]) rot270 = false;
            }
        }
        return rot0 || rot90 || rot180 || rot270;
    }
}
```
**Python**
```
class Solution:
    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:
        n = len(mat)
        rot0, rot90, rot180, rot270 = True, True, True, True

        for i in range(n):
            for j in range(n):
                v = mat[i][j]
                if v != target[i][j]:
                    rot0 = False
                if v != target[j][n - 1 - i]:
                    rot90 = False
                if v != target[n - 1 - i][n - 1 - j]:
                    rot180 = False
                if v != target[n - 1 - j][i]:
                    rot270 = False
        return rot0 or rot90 or rot180 or rot270
        
```

---

- Recommendation by rotation simulation
```
class Solution:
    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:
        n = len(mat)
        
        for k in range(4):
            for i in range(n // 2):
                for j in range((n + 1) // 2):
                    mat[i][j], mat[n-1-j][i], mat[n-1-i][n-1-j], mat[j][n-1-i] \
                        = mat[n-1-j][i], mat[n-1-i][n-1-j], mat[j][n-1-i], mat[i][j]
            if mat == target:
                return True
        return False
        
```
