https://leetcode.cn/problems/longest-nice-substring/description/

- Solution by divide-and-conquer with copilot
```
public class Solution {
    public string LongestNiceSubstring(string s) {
        return Dfs(s);
    }

    private string Dfs(string s)
    {
        if (s.Length < 2) return string.Empty;

        // Collect characters present
        var set = new HashSet<char>(s);
        for (var i = 0; i < s.Length; i++)
        {
            var c = s[i];
            // If counterpart case not present, split around i
            if (!(set.Contains(char.ToLower(c)) && set.Contains(char.ToUpper(c))))
            {
                var left = Dfs(s.Substring(0, i));
                var right = Dfs(s.Substring(i + 1));
                return left.Length >= right.Length ? left : right;
            }
        }
        // While string is nice
        return s;
    }
}
```

---

- Recommendation 1 by enumeration
```
public class Solution {
    public string LongestNiceSubstring(string s) {
        var n = s.Length;
        var maxPos = 0;
        var maxLen = 0;
        for (var i = 0; i < n; i++)
        {
            var lower = 0;
            var upper = 0;
            for (var j = i; j < n; j++)
            {
                if (char.IsLower(s[j]))
                    lower |= 1 << (s[j] - 'a');
                else
                    upper |= 1 << (s[j] - 'A');
                if (lower == upper && j - i + 1 > maxLen)
                {
                    maxPos = i;
                    maxLen = j - i + 1;
                }
            }
        }
        return s.Substring(maxPos, maxLen);
    }
}
```
**Python**
```
class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        n = len(s)
        max_pos, max_len = 0, 0
        for i in range(n):
            lower, upper = 0, 0
            for j in range(i, n):
                if s[j].islower():
                    lower |= 1 << (ord(s[j]) - ord('a'))
                else:
                    upper |= 1 << (ord(s[j]) - ord('A'))
                if lower == upper and j - i + 1 > max_len:
                    max_pos = i
                    max_len = j - i + 1
        return s[max_pos: max_pos + max_len]
        
```
